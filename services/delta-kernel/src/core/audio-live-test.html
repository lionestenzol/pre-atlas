<!DOCTYPE html>
<html>
<head>
  <title>Delta Audio - Live Test</title>
  <style>
    body {
      font-family: monospace;
      background: #1a1a1a;
      color: #00ff00;
      padding: 20px;
      max-width: 800px;
      margin: 0 auto;
    }
    .panel {
      background: #0a0a0a;
      border: 1px solid #333;
      padding: 15px;
      border-radius: 4px;
      margin: 15px 0;
    }
    h1, h2 { color: #0f0; margin-top: 0; }
    button {
      background: #0f0;
      color: #000;
      border: none;
      padding: 10px 20px;
      font-family: monospace;
      font-weight: bold;
      cursor: pointer;
      margin: 5px;
    }
    button:hover { background: #0c0; }
    button:disabled { background: #333; color: #666; }
    .band-container {
      display: flex;
      gap: 10px;
      align-items: flex-end;
      height: 200px;
      background: #000;
      padding: 10px;
      border: 1px solid #333;
    }
    .band {
      flex: 1;
      background: #0f0;
      transition: height 0.05s;
      min-height: 2px;
    }
    .band-label {
      display: flex;
      justify-content: space-around;
      font-size: 11px;
      color: #666;
      margin-top: 5px;
    }
    #stats {
      white-space: pre;
      font-size: 12px;
      line-height: 1.4;
    }
    .speaking { color: #ff0; font-weight: bold; }
    .silent { color: #666; }
    .delta-log {
      height: 150px;
      overflow-y: auto;
      font-size: 11px;
      background: #000;
      padding: 10px;
      border: 1px solid #333;
    }
    .delta-entry { margin: 2px 0; color: #0f0; }
    .receiver-panel {
      border-color: #0ff;
    }
    .receiver-panel h2 { color: #0ff; }
    .receiver-panel .band { background: #0ff; }
  </style>
</head>
<body>
  <h1>Delta-State Audio Streaming - Live Test</h1>
  <p>Voice over LoRa. 4 frequency bands. ~30 bytes/sec.</p>

  <div>
    <button id="startBtn">Start Microphone</button>
    <button id="stopBtn" disabled>Stop</button>
    <button id="playbackBtn" disabled>Play Receiver</button>
  </div>

  <div class="panel">
    <h2>Sender (Your Microphone)</h2>
    <div class="band-container">
      <div class="band" id="band0" style="height: 2px;"></div>
      <div class="band" id="band1" style="height: 2px;"></div>
      <div class="band" id="band2" style="height: 2px;"></div>
      <div class="band" id="band3" style="height: 2px;"></div>
    </div>
    <div class="band-label">
      <span>80-300Hz<br>Bass</span>
      <span>300-1kHz<br>Vowels</span>
      <span>1-3kHz<br>Clarity</span>
      <span>3-8kHz<br>Presence</span>
    </div>
    <div id="speakingStatus" class="silent" style="margin-top: 10px;">Silent</div>
  </div>

  <div class="panel receiver-panel">
    <h2>Receiver (Reconstructed from Deltas)</h2>
    <div class="band-container">
      <div class="band" id="rxBand0" style="height: 2px;"></div>
      <div class="band" id="rxBand1" style="height: 2px;"></div>
      <div class="band" id="rxBand2" style="height: 2px;"></div>
      <div class="band" id="rxBand3" style="height: 2px;"></div>
    </div>
    <div class="band-label">
      <span>80-300Hz</span>
      <span>300-1kHz</span>
      <span>1-3kHz</span>
      <span>3-8kHz</span>
    </div>
  </div>

  <div class="panel">
    <h2>Statistics</h2>
    <div id="stats">Waiting for microphone...</div>
  </div>

  <div class="panel">
    <h2>Delta Log (last 30)</h2>
    <div id="deltaLog" class="delta-log"></div>
  </div>

  <script type="module">
    // Constants
    const AUDIO_BANDS = [
      [80, 300],
      [300, 1000],
      [1000, 3000],
      [3000, 8000],
    ];
    const FFT_SIZE = 512;
    const DELTA_THRESHOLD = 3;
    const SILENCE_THRESHOLD = 15;

    // State
    let audioCtx = null;
    let analyser = null;
    let stream = null;
    let running = false;
    let lastBands = [0, 0, 0, 0];
    let receiverBands = [0, 0, 0, 0];

    // Metrics
    let startTime = 0;
    let framesProcessed = 0;
    let deltasEmitted = 0;
    let totalBytes = 0;
    let deltaLog = [];
    let deltaLedger = [];

    // Playback
    let playbackCtx = null;
    let isPlaying = false;

    // DOM
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const playbackBtn = document.getElementById('playbackBtn');
    const statsEl = document.getElementById('stats');
    const speakingEl = document.getElementById('speakingStatus');
    const deltaLogEl = document.getElementById('deltaLog');

    // Update band display
    function updateBands(bands, prefix = '') {
      bands.forEach((value, i) => {
        const el = document.getElementById(`${prefix}band${i}`);
        if (el) {
          const height = Math.max(2, (value / 255) * 180);
          el.style.height = `${height}px`;
        }
      });
    }

    // Extract band energies from frequency data
    function extractBands(frequencyData, sampleRate) {
      return AUDIO_BANDS.map(([low, high]) => {
        const lowBin = Math.floor((low / sampleRate) * frequencyData.length * 2);
        const highBin = Math.floor((high / sampleRate) * frequencyData.length * 2);
        const clampedLow = Math.max(0, Math.min(lowBin, frequencyData.length - 1));
        const clampedHigh = Math.max(0, Math.min(highBin, frequencyData.length - 1));

        let sum = 0;
        let count = 0;
        for (let i = clampedLow; i <= clampedHigh; i++) {
          sum += frequencyData[i];
          count++;
        }
        return count > 0 ? Math.floor(sum / count) : 0;
      });
    }

    // Create compact delta
    function createDelta(bandIndex, oldValue, newValue) {
      const delta = {
        b: bandIndex,
        v: newValue,
        d: newValue - oldValue,
        t: Date.now() - startTime,
      };

      // Simulate compact binary size: 4 bytes
      // [bandIndex:1][value:1][delta:1][timestamp:1]
      const bytes = 4;

      return { delta, bytes };
    }

    // Apply delta to receiver
    function applyDelta(delta) {
      receiverBands[delta.b] = delta.v;
      updateBands(receiverBands, 'rx');
    }

    // Synthesize audio from bands
    function synthesizeBands(bands) {
      if (!playbackCtx || !isPlaying) return;

      const frequencies = [200, 600, 1800, 5000];
      const totalEnergy = bands.reduce((a, b) => a + b, 0);

      if (totalEnergy < SILENCE_THRESHOLD * 4) return;

      bands.forEach((energy, i) => {
        if (energy < 10) return;

        const osc = playbackCtx.createOscillator();
        const gain = playbackCtx.createGain();

        osc.type = i < 2 ? 'sawtooth' : 'sine';
        osc.frequency.value = frequencies[i];

        const gainValue = Math.log1p(energy) / Math.log1p(255) * 0.15;
        gain.gain.value = gainValue;
        gain.gain.exponentialRampToValueAtTime(0.001, playbackCtx.currentTime + 0.08);

        osc.connect(gain);
        gain.connect(playbackCtx.destination);

        osc.start();
        osc.stop(playbackCtx.currentTime + 0.1);
      });
    }

    // Update stats
    function updateStats() {
      const elapsed = (Date.now() - startTime) / 1000;
      const deltasPerSec = deltasEmitted / elapsed;
      const bytesPerSec = totalBytes / elapsed;

      statsEl.textContent = `
Elapsed:       ${elapsed.toFixed(1)}s
Frames:        ${framesProcessed}

Deltas:        ${deltasEmitted}
Deltas/sec:    ${deltasPerSec.toFixed(1)}

Bytes:         ${totalBytes}
Bytes/sec:     ${bytesPerSec.toFixed(1)}

Bands:         [${lastBands.join(', ')}]
Receiver:      [${receiverBands.join(', ')}]

Playback:      ${isPlaying ? 'ON' : 'OFF'}
`.trim();
    }

    // Log delta
    function logDelta(delta, bytes) {
      const entry = `[${delta.t}ms] Band${delta.b}: ${delta.v} (Î”${delta.d > 0 ? '+' : ''}${delta.d}) ${bytes}B`;
      deltaLog.unshift(entry);
      deltaLog = deltaLog.slice(0, 30);
      deltaLogEl.innerHTML = deltaLog.map(e => `<div class="delta-entry">${e}</div>`).join('');
    }

    // Process audio frame
    function processFrame() {
      if (!running) return;

      const frequencyData = new Uint8Array(analyser.frequencyBinCount);
      analyser.getByteFrequencyData(frequencyData);
      framesProcessed++;

      const bands = extractBands(frequencyData, audioCtx.sampleRate);
      updateBands(bands);

      // Detect speaking
      const totalEnergy = bands.reduce((a, b) => a + b, 0);
      const isSpeaking = totalEnergy > SILENCE_THRESHOLD * 4;

      if (isSpeaking) {
        speakingEl.textContent = 'SPEAKING';
        speakingEl.className = 'speaking';
      } else {
        speakingEl.textContent = 'Silent';
        speakingEl.className = 'silent';
      }

      // Emit deltas for changed bands
      bands.forEach((value, i) => {
        const diff = Math.abs(value - lastBands[i]);
        if (diff > DELTA_THRESHOLD) {
          const { delta, bytes } = createDelta(i, lastBands[i], value);

          deltasEmitted++;
          totalBytes += bytes;
          deltaLedger.push(delta);

          logDelta(delta, bytes);
          applyDelta(delta);

          // Synthesize if playing
          if (isPlaying) {
            synthesizeBands(receiverBands);
          }
        }
      });

      lastBands = [...bands];
      updateStats();

      requestAnimationFrame(processFrame);
    }

    // Start capture
    async function startCapture() {
      try {
        stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        audioCtx = new AudioContext();
        const source = audioCtx.createMediaStreamSource(stream);
        analyser = audioCtx.createAnalyser();
        analyser.fftSize = FFT_SIZE;

        source.connect(analyser);

        running = true;
        startTime = Date.now();
        framesProcessed = 0;
        deltasEmitted = 0;
        totalBytes = 0;
        deltaLog = [];
        deltaLedger = [];
        lastBands = [0, 0, 0, 0];
        receiverBands = [0, 0, 0, 0];

        startBtn.disabled = true;
        stopBtn.disabled = false;
        playbackBtn.disabled = false;

        processFrame();

      } catch (err) {
        alert('Microphone error: ' + err.message);
      }
    }

    // Stop capture
    function stopCapture() {
      running = false;
      if (stream) {
        stream.getTracks().forEach(t => t.stop());
        stream = null;
      }
      if (audioCtx) {
        audioCtx.close();
        audioCtx = null;
      }
      if (playbackCtx) {
        playbackCtx.close();
        playbackCtx = null;
      }

      isPlaying = false;
      startBtn.disabled = false;
      stopBtn.disabled = true;
      playbackBtn.disabled = true;
      playbackBtn.textContent = 'Play Receiver';
    }

    // Toggle playback
    function togglePlayback() {
      if (isPlaying) {
        isPlaying = false;
        if (playbackCtx) {
          playbackCtx.close();
          playbackCtx = null;
        }
        playbackBtn.textContent = 'Play Receiver';
      } else {
        playbackCtx = new AudioContext();
        isPlaying = true;
        playbackBtn.textContent = 'Mute Receiver';
      }
    }

    // Event listeners
    startBtn.addEventListener('click', startCapture);
    stopBtn.addEventListener('click', stopCapture);
    playbackBtn.addEventListener('click', togglePlayback);
  </script>
</body>
</html>
